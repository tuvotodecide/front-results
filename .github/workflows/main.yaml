name: CI & CD

on:
  push:
    branches: [main]
    tags: ["v*"]
    paths:
      - "Dockerfile"
      - "package.json"
      - "src/**"
      - "public/**"
      - "vite.config.ts"
      - ".github/workflows/**"

env:
  BUILD_PLATFORMS: linux/arm64

jobs:
  build:
    name: Build & Push Docker image
    runs-on: ubuntu-latest
    environment: devops_aws
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}
      ECR_REPO: ${{ vars.ECR_REPOSITORY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select env & image tag
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "‚ñ∂Ô∏è Build in PROD"
            echo "${{ vars.ENV_PROD }}" > .env
            echo "image_tag=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "alias_tag=prod" >> $GITHUB_OUTPUT
          else
            echo "‚ñ∂Ô∏è Build in DEV"
            echo "${{ vars.ENV_PROD }}" > .env
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "alias_tag=dev" >> $GITHUB_OUTPUT
          fi
          echo "‚éø wrote .env with tag: $(cat $GITHUB_OUTPUT)"

      - name: Set up QEMU (binfmt)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:v0.12.1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push (multi-arch)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile
          push: true
          platforms: ${{ env.BUILD_PLATFORMS }}
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:${{ steps.meta.outputs.image_tag }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:${{ steps.meta.outputs.alias_tag }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:${{ github.sha }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:${{ steps.meta.outputs.alias_tag }}
          cache-to: type=inline

  deploy:
    name: Deploy to EC2 via SSM
    needs: build
    runs-on: ubuntu-latest
    environment: devops_aws
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}
      ECR_REPO: ${{ vars.ECR_REPOSITORY }}
      IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      PUBLIC_IP: ${{ vars.PUBLIC_IP }}
      EXTERNAL_PORT: ${{ vars.EXTERNAL_PORT }}
      CONTAINER_NAME: yocustodio-app
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy container via SSM
        id: ssm
        shell: bash
        run: |
          set -euo pipefail
          echo "üì¶ Deploying $ECR_REGISTRY/$ECR_REPO:$IMAGE_TAG to $EC2_INSTANCE_ID"

          CMDS=$(jq -nc --arg reg "$ECR_REGISTRY" \
            --arg repo "$ECR_REPO" \
            --arg region "$AWS_REGION" \
            --arg port "${EXTERNAL_PORT}" \
            --arg name "$CONTAINER_NAME" \
            --arg tag "$IMAGE_TAG" \
            '
          [
            "aws ecr get-login-password --region \($region) | docker login --username AWS --password-stdin \($reg)",
            "docker pull \($reg)/\($repo):\($tag)",
            "docker stop \($name) || true",
            "docker rm \($name) || true",
            "docker run -d --name \($name) -p \($port):80 --restart unless-stopped \($reg)/\($repo):\($tag)",
            "docker image prune -f"
          ]')

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$EC2_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "GitHub Actions deploy" \
            --parameters "commands=$CMDS" \
            --output text \
            --query "Command.CommandId")
          echo "‚ñ∂Ô∏è SSM CommandId = $CMD_ID"

          aws ssm wait command-executed --command-id "$CMD_ID" --instance-id "$EC2_INSTANCE_ID"

          aws ssm get-command-invocation \
            --command-id "$CMD_ID" --instance-id "$EC2_INSTANCE_ID" \
            --query "{Stdout:StandardOutputContent, Stderr:StandardErrorContent, Status:Status}" \
            --output text | sed 's/\\n/\n/g'

          STATUS=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" --instance-id "$EC2_INSTANCE_ID" \
            --query Status --output text)
          [[ "$STATUS" == "Success" ]] || { echo "‚ùå Remote script failed"; exit 1; }

      - name: Verify container is running
        run: |
          aws ssm send-command \
            --instance-ids "$EC2_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=docker inspect -f '{{.State.Running}}' $CONTAINER_NAME" \
            --query "Command.CommandId" --output text \
          | xargs -I{} aws ssm wait command-executed --command-id {} --instance-id "$EC2_INSTANCE_ID"

      - name: Health check loop
        shell: bash
        run: |
          set -euo pipefail
          stdbuf -oL -eL echo "üîé Comprobando http://${PUBLIC_IP}:${EXTERNAL_PORT}/"
          for i in {1..24}; do # = 2 minutos m√°x.
            http_code=$(curl -s -o /dev/null -w '%{http_code}' --max-time 5 "http://${PUBLIC_IP}:${EXTERNAL_PORT}/") || true
            if [[ "$http_code" == "200" ]]; then
              echo "‚úÖ Servicio OK (${http_code})"; exit 0
            fi
            echo "‚è≥ intento $i/24 ‚Äî code=${http_code:-timeout}"
            sleep 5
          done
          echo "‚ùå Health-check failed, dumping container logs"
          aws ssm send-command \
            --instance-ids "$EC2_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=docker logs --tail 200 $CONTAINER_NAME" \
            --query "Command.CommandId" --output text \
          | xargs -I{} aws ssm wait command-executed --command-id {} --instance-id "$EC2_INSTANCE_ID"
          exit 1
